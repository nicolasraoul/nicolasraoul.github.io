<!--
VibeDiff

VibeDiff is a state-of-the-art, self-contained, offline-capable visual diff tool designed for rapid iteration and code comparison.

Features:
- Zero Dependencies: A single HTML file containing all logic and styling. No network requests, no installation.
- Secure & Offline: Runs entirely in your browser. Safe for sensitive code.
- Rapid Version Cycling:
    - Paste a new version into the "New" panel, and the previous "New" version automatically shifts to "Old".
    - Seamlessly compare v61 vs v62, then v62 vs v63 with a single paste action.
- Smart Diffing: Uses advanced algorithms (Myers Diff) to highlight semantic changes in source code (Go, SQL, etc.).
- Live Editing: The "New" panel is fully editable with real-time diff updates.
- History Tracking: Remembers previous versions for quick backtracking.

Usage:
1. Download `vibediff.html`.
2. Open it in any modern web browser.
3. Paste your "Old" code on the left (optional).
4. Paste your "New" code on the right.
5. To compare a newer version, simply paste it into the "New" panel. The tool automatically cycles the previous "New" content to the "Old" panel.

License: Open Source.
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeDiff</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --text-color: #d4d4d4;
            --pane-bg: #252526;
            --border-color: #333;
            --diff-add-bg: #203c25;
            --diff-add-text: #b5cea8;
            --diff-del-bg: #4b1818;
            --diff-del-text: #ce9178;
            --header-height: 50px;
            --font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            height: var(--header-height);
            background-color: #333333;
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            background-color: #0e639c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #1177bb;
        }

        button.secondary {
            background-color: #444;
        }

        button.secondary:hover {
            background-color: #555;
        }

        #main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            min-width: 0;
            /* Prevent flex item from overflowing */
        }

        .pane:last-child {
            border-right: none;
        }

        .pane-header {
            padding: 8px 16px;
            background-color: #2d2d2d;
            font-size: 0.85rem;
            font-weight: 600;
            color: #ccc;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            /* Prevent container from scrolling, let textarea handle it */
            background-color: var(--pane-bg);
        }

        /* We use a textarea for input but overlay a div for rendering diffs */
        textarea.source-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 10px;
            border: none;
            resize: none;
            background: transparent;
            color: transparent;
            /* Text is hidden, caret is visible */
            caret-color: white;
            font-family: var(--font-family);
            font-size: 14px;
            line-height: 21px;
            /* Fixed line height for scroll math */
            z-index: 2;
            outline: none;
            white-space: pre;
            /* No wrapping for code */
            overflow: auto;
            /* Scrollbars on textarea */
            box-sizing: border-box;
        }

        .diff-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Match textarea height */
            margin: 0;
            padding: 10px;
            font-family: var(--font-family);
            font-size: 14px;
            line-height: 21px;
            /* Fixed line height for scroll math */
            white-space: pre;
            /* Match textarea wrapping */
            word-break: normal;
            /* Don't break words in code */
            box-sizing: border-box;
            pointer-events: none;
            /* Let clicks pass through to textarea */
            z-index: 1;
            overflow: hidden;
            /* Hide scrollbars, sync via JS */
        }

        /* Specific styles for the Old pane (read-only usually, but we make it editable for flexibility) */
        #old-pane .source-input {
            /* color: var(--text-color);  <-- Removed to prevent duplication with overlay */
            z-index: 1;
        }

        /* When diffing, we might want to hide the text in Old pane too if we render diffs there? 
           Actually, for "Old", we usually just show the text. 
           But to show deletions, we need the diff view.
        */

        /* Unified approach: 
           Both panes have a textarea and a pre/div for rendering.
           We will render the diff in BOTH.
           Left pane shows deletions (and context).
           Right pane shows insertions (and context).
        */

        ins {
            background-color: var(--diff-add-bg);
            color: var(--diff-add-text);
            text-decoration: none;
            border-radius: 2px;
        }

        del {
            background-color: var(--diff-del-bg);
            color: var(--diff-del-text);
            text-decoration: none;
            border-radius: 2px;
        }

        .status-bar {
            height: 25px;
            background-color: #007acc;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 0.8rem;
        }

        /* Scroll syncing */
        /* We will implement JS scroll syncing */
    </style>
</head>

<body>

    <header>
        <h1>VibeDiff</h1>
        <div class="controls">
            <button class="secondary" id="undo-btn" title="Undo version cycle">Undo</button>
            <button id="cycle-btn" title="Manually cycle versions">Cycle (New &rarr; Old)</button>
        </div>
    </header>

    <div id="main-container">
        <div class="pane" id="old-pane">
            <div class="pane-header">
                <span>OLD VERSION</span>
                <span id="old-len">0 chars</span>
            </div>
            <div class="editor-container">
                <div class="diff-view" id="old-diff-view"></div>
                <textarea class="source-input" id="old-input" spellcheck="false"
                    placeholder="Paste old version here..."></textarea>
            </div>
        </div>
        <div class="pane" id="new-pane">
            <div class="pane-header">
                <span>NEW VERSION (Paste here to cycle)</span>
                <span id="new-len">0 chars</span>
            </div>
            <div class="editor-container">
                <div class="diff-view" id="new-diff-view"></div>
                <textarea class="source-input" id="new-input" spellcheck="false"
                    placeholder="Paste new version here..."></textarea>
            </div>
        </div>
    </div>

    <div class="status-bar" id="status-bar">
        Ready.
    </div>

    <script>
        // INLINED DIFF_MATCH_PATCH LIBRARY
        var diff_match_patch = function () { this.Diff_Timeout = 1; this.Diff_EditCost = 4; this.Match_Threshold = .5; this.Match_Distance = 1E3; this.Patch_DeleteThreshold = .5; this.Patch_Margin = 4; this.Match_MaxBits = 32 }, DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0; diff_match_patch.Diff = function (a, b) { this[0] = a; this[1] = b }; diff_match_patch.Diff.prototype.length = 2; diff_match_patch.Diff.prototype.toString = function () { return this[0] + "," + this[1] };
        diff_match_patch.prototype.diff_main = function (a, b, c, d) {
            "undefined" == typeof d && (d = 0 >= this.Diff_Timeout ? Number.MAX_VALUE : (new Date).getTime() + 1E3 * this.Diff_Timeout); if (null == a || null == b) throw Error("Null input. (diff_main)"); if (a == b) return a ? [new diff_match_patch.Diff(DIFF_EQUAL, a)] : []; "undefined" == typeof c && (c = !0); var e = c, f = this.diff_commonPrefix(a, b); c = a.substring(0, f); a = a.substring(f); b = b.substring(f); f = this.diff_commonSuffix(a, b); var g = a.substring(a.length - f); a = a.substring(0, a.length - f); b = b.substring(0,
                b.length - f); a = this.diff_compute_(a, b, e, d); c && a.unshift(new diff_match_patch.Diff(DIFF_EQUAL, c)); g && a.push(new diff_match_patch.Diff(DIFF_EQUAL, g)); this.diff_cleanupMerge(a); return a
        };
        diff_match_patch.prototype.diff_compute_ = function (a, b, c, d) {
            if (!a) return [new diff_match_patch.Diff(DIFF_INSERT, b)]; if (!b) return [new diff_match_patch.Diff(DIFF_DELETE, a)]; var e = a.length > b.length ? a : b, f = a.length > b.length ? b : a, g = e.indexOf(f); return -1 != g ? (c = [new diff_match_patch.Diff(DIFF_INSERT, e.substring(0, g)), new diff_match_patch.Diff(DIFF_EQUAL, f), new diff_match_patch.Diff(DIFF_INSERT, e.substring(g + f.length))], a.length > b.length && (c[0][0] = c[2][0] = DIFF_DELETE), c) : 1 == f.length ? [new diff_match_patch.Diff(DIFF_DELETE,
                a), new diff_match_patch.Diff(DIFF_INSERT, b)] : (e = this.diff_halfMatch_(a, b)) ? (b = e[1], f = e[3], a = e[4], e = this.diff_main(e[0], e[2], c, d), c = this.diff_main(b, f, c, d), e.concat([new diff_match_patch.Diff(DIFF_EQUAL, a)], c)) : c && 100 < a.length && 100 < b.length ? this.diff_lineMode_(a, b, d) : this.diff_bisect_(a, b, d)
        };
        diff_match_patch.prototype.diff_lineMode_ = function (a, b, c) {
            var d = this.diff_linesToChars_(a, b); a = d.chars1; b = d.chars2; d = d.lineArray; a = this.diff_main(a, b, !1, c); this.diff_charsToLines_(a, d); this.diff_cleanupSemantic(a); a.push(new diff_match_patch.Diff(DIFF_EQUAL, "")); for (var e = d = b = 0, f = "", g = ""; b < a.length;) {
                switch (a[b][0]) {
                    case DIFF_INSERT: e++; g += a[b][1]; break; case DIFF_DELETE: d++; f += a[b][1]; break; case DIFF_EQUAL: if (1 <= d && 1 <= e) {
                        a.splice(b - d - e, d + e); b = b - d - e; d = this.diff_main(f, g, !1, c); for (e = d.length - 1; 0 <= e; e--)a.splice(b,
                            0, d[e]); b += d.length
                    } d = e = 0; g = f = ""
                }b++
            } a.pop(); return a
        };
        diff_match_patch.prototype.diff_bisect_ = function (a, b, c) {
            for (var d = a.length, e = b.length, f = Math.ceil((d + e) / 2), g = 2 * f, h = Array(g), l = Array(g), k = 0; k < g; k++)h[k] = -1, l[k] = -1; h[f + 1] = 0; l[f + 1] = 0; k = d - e; for (var m = 0 != k % 2, p = 0, x = 0, w = 0, q = 0, t = 0; t < f && !((new Date).getTime() > c); t++) {
                for (var v = -t + p; v <= t - x; v += 2) {
                    var n = f + v; var r = v == -t || v != t && h[n - 1] < h[n + 1] ? h[n + 1] : h[n - 1] + 1; for (var y = r - v; r < d && y < e && a.charAt(r) == b.charAt(y);)r++, y++; h[n] = r; if (r > d) x += 2; else if (y > e) p += 2; else if (m && (n = f + k - v, 0 <= n && n < g && -1 != l[n])) {
                        var u = d - l[n]; if (r >=
                            u) return this.diff_bisectSplit_(a, b, r, y, c)
                    }
                } for (v = -t + w; v <= t - q; v += 2) { n = f + v; u = v == -t || v != t && l[n - 1] < l[n + 1] ? l[n + 1] : l[n - 1] + 1; for (r = u - v; u < d && r < e && a.charAt(d - u - 1) == b.charAt(e - r - 1);)u++, r++; l[n] = u; if (u > d) q += 2; else if (r > e) w += 2; else if (!m && (n = f + k - v, 0 <= n && n < g && -1 != h[n] && (r = h[n], y = f + r - n, u = d - u, r >= u))) return this.diff_bisectSplit_(a, b, r, y, c) }
            } return [new diff_match_patch.Diff(DIFF_DELETE, a), new diff_match_patch.Diff(DIFF_INSERT, b)]
        };
        diff_match_patch.prototype.diff_bisectSplit_ = function (a, b, c, d, e) { var f = a.substring(0, c), g = b.substring(0, d); a = a.substring(c); b = b.substring(d); f = this.diff_main(f, g, !1, e); e = this.diff_main(a, b, !1, e); return f.concat(e) };
        diff_match_patch.prototype.diff_linesToChars_ = function (a, b) { function c(a) { for (var b = "", c = 0, g = -1, h = d.length; g < a.length - 1;) { g = a.indexOf("\n", c); -1 == g && (g = a.length - 1); var l = a.substring(c, g + 1); (e.hasOwnProperty ? e.hasOwnProperty(l) : void 0 !== e[l]) ? b += String.fromCharCode(e[l]) : (h == f && (l = a.substring(c), g = a.length), b += String.fromCharCode(h), e[l] = h, d[h++] = l); c = g + 1 } return b } var d = [], e = {}; d[0] = ""; var f = 4E4, g = c(a); f = 65535; var h = c(b); return { chars1: g, chars2: h, lineArray: d } };
        diff_match_patch.prototype.diff_charsToLines_ = function (a, b) { for (var c = 0; c < a.length; c++) { for (var d = a[c][1], e = [], f = 0; f < d.length; f++)e[f] = b[d.charCodeAt(f)]; a[c][1] = e.join("") } }; diff_match_patch.prototype.diff_commonPrefix = function (a, b) { if (!a || !b || a.charAt(0) != b.charAt(0)) return 0; for (var c = 0, d = Math.min(a.length, b.length), e = d, f = 0; c < e;)a.substring(f, e) == b.substring(f, e) ? f = c = e : d = e, e = Math.floor((d - c) / 2 + c); return e };
        diff_match_patch.prototype.diff_commonSuffix = function (a, b) { if (!a || !b || a.charAt(a.length - 1) != b.charAt(b.length - 1)) return 0; for (var c = 0, d = Math.min(a.length, b.length), e = d, f = 0; c < e;)a.substring(a.length - e, a.length - f) == b.substring(b.length - e, b.length - f) ? f = c = e : d = e, e = Math.floor((d - c) / 2 + c); return e };
        diff_match_patch.prototype.diff_commonOverlap_ = function (a, b) { var c = a.length, d = b.length; if (0 == c || 0 == d) return 0; c > d ? a = a.substring(c - d) : c < d && (b = b.substring(0, c)); c = Math.min(c, d); if (a == b) return c; d = 0; for (var e = 1; ;) { var f = a.substring(c - e); f = b.indexOf(f); if (-1 == f) return d; e += f; if (0 == f || a.substring(c - e) == b.substring(0, e)) d = e, e++ } };
        diff_match_patch.prototype.diff_halfMatch_ = function (a, b) {
            function c(a, b, c) { for (var d = a.substring(c, c + Math.floor(a.length / 4)), e = -1, g = "", h, k, l, m; -1 != (e = b.indexOf(d, e + 1));) { var p = f.diff_commonPrefix(a.substring(c), b.substring(e)), u = f.diff_commonSuffix(a.substring(0, c), b.substring(0, e)); g.length < u + p && (g = b.substring(e - u, e) + b.substring(e, e + p), h = a.substring(0, c - u), k = a.substring(c + p), l = b.substring(0, e - u), m = b.substring(e + p)) } return 2 * g.length >= a.length ? [h, k, l, m, g] : null } if (0 >= this.Diff_Timeout) return null;
            var d = a.length > b.length ? a : b, e = a.length > b.length ? b : a; if (4 > d.length || 2 * e.length < d.length) return null; var f = this, g = c(d, e, Math.ceil(d.length / 4)); d = c(d, e, Math.ceil(d.length / 2)); if (g || d) g = d ? g ? g[4].length > d[4].length ? g : d : d : g; else return null; if (a.length > b.length) { d = g[0]; e = g[1]; var h = g[2]; var l = g[3] } else h = g[0], l = g[1], d = g[2], e = g[3]; return [d, e, h, l, g[4]]
        };
        diff_match_patch.prototype.diff_cleanupSemantic = function (a) {
            for (var b = !1, c = [], d = 0, e = null, f = 0, g = 0, h = 0, l = 0, k = 0; f < a.length;)a[f][0] == DIFF_EQUAL ? (c[d++] = f, g = l, h = k, k = l = 0, e = a[f][1]) : (a[f][0] == DIFF_INSERT ? l += a[f][1].length : k += a[f][1].length, e && e.length <= Math.max(g, h) && e.length <= Math.max(l, k) && (a.splice(c[d - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, e)), a[c[d - 1] + 1][0] = DIFF_INSERT, d--, d--, f = 0 < d ? c[d - 1] : -1, k = l = h = g = 0, e = null, b = !0)), f++; b && this.diff_cleanupMerge(a); this.diff_cleanupSemanticLossless(a); for (f = 1; f <
                a.length;) {
                if (a[f - 1][0] == DIFF_DELETE && a[f][0] == DIFF_INSERT) {
                    b = a[f - 1][1]; c = a[f][1]; d = this.diff_commonOverlap_(b, c); e = this.diff_commonOverlap_(c, b); if (d >= e) { if (d >= b.length / 2 || d >= c.length / 2) a.splice(f, 0, new diff_match_patch.Diff(DIFF_EQUAL, c.substring(0, d))), a[f - 1][1] = b.substring(0, b.length - d), a[f + 1][1] = c.substring(d), f++ } else if (e >= b.length / 2 || e >= c.length / 2) a.splice(f, 0, new diff_match_patch.Diff(DIFF_EQUAL, b.substring(0, e))), a[f - 1][0] = DIFF_INSERT, a[f - 1][1] = c.substring(0, c.length - e), a[f + 1][0] = DIFF_DELETE,
                        a[f + 1][1] = b.substring(e), f++; f++
                } f++
            }
        };
        diff_match_patch.prototype.diff_cleanupSemanticLossless = function (a) {
            function b(a, b) {
                if (!a || !b) return 6; var c = a.charAt(a.length - 1), d = b.charAt(0), e = c.match(diff_match_patch.nonAlphaNumericRegex_), f = d.match(diff_match_patch.nonAlphaNumericRegex_), g = e && c.match(diff_match_patch.whitespaceRegex_), h = f && d.match(diff_match_patch.whitespaceRegex_); c = g && c.match(diff_match_patch.linebreakRegex_); d = h && d.match(diff_match_patch.linebreakRegex_); var k = c && a.match(diff_match_patch.blanklineEndRegex_), l = d && b.match(diff_match_patch.blanklineStartRegex_);
                return k || l ? 5 : c || d ? 4 : e && !g && h ? 3 : g || h ? 2 : e || f ? 1 : 0
            } for (var c = 1; c < a.length - 1;) {
                if (a[c - 1][0] == DIFF_EQUAL && a[c + 1][0] == DIFF_EQUAL) {
                    var d = a[c - 1][1], e = a[c][1], f = a[c + 1][1], g = this.diff_commonSuffix(d, e); if (g) { var h = e.substring(e.length - g); d = d.substring(0, d.length - g); e = h + e.substring(0, e.length - g); f = h + f } g = d; h = e; for (var l = f, k = b(d, e) + b(e, f); e.charAt(0) === f.charAt(0);) { d += e.charAt(0); e = e.substring(1) + f.charAt(0); f = f.substring(1); var m = b(d, e) + b(e, f); m >= k && (k = m, g = d, h = e, l = f) } a[c - 1][1] != g && (g ? a[c - 1][1] = g : (a.splice(c -
                        1, 1), c--), a[c][1] = h, l ? a[c + 1][1] = l : (a.splice(c + 1, 1), c--))
                } c++
            }
        }; diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/; diff_match_patch.whitespaceRegex_ = /\s/; diff_match_patch.linebreakRegex_ = /[\r\n]/; diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/; diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
        diff_match_patch.prototype.diff_cleanupEfficiency = function (a) { for (var b = !1, c = [], d = 0, e = null, f = 0, g = !1, h = !1, l = !1, k = !1; f < a.length;)a[f][0] == DIFF_EQUAL ? (a[f][1].length < this.Diff_EditCost && (l || k) ? (c[d++] = f, g = l, h = k, e = a[f][1]) : (d = 0, e = null), l = k = !1) : (a[f][0] == DIFF_DELETE ? k = !0 : l = !0, e && (g && h && l && k || e.length < this.Diff_EditCost / 2 && 3 == g + h + l + k) && (a.splice(c[d - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, e)), a[c[d - 1] + 1][0] = DIFF_INSERT, d--, e = null, g && h ? (l = k = !0, d = 0) : (d--, f = 0 < d ? c[d - 1] : -1, l = k = !1), b = !0)), f++; b && this.diff_cleanupMerge(a) };
        diff_match_patch.prototype.diff_cleanupMerge = function (a) {
            a.push(new diff_match_patch.Diff(DIFF_EQUAL, "")); for (var b = 0, c = 0, d = 0, e = "", f = "", g; b < a.length;)switch (a[b][0]) {
                case DIFF_INSERT: d++; f += a[b][1]; b++; break; case DIFF_DELETE: c++; e += a[b][1]; b++; break; case DIFF_EQUAL: 1 < c + d ? (0 !== c && 0 !== d && (g = this.diff_commonPrefix(f, e), 0 !== g && (0 < b - c - d && a[b - c - d - 1][0] == DIFF_EQUAL ? a[b - c - d - 1][1] += f.substring(0, g) : (a.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL, f.substring(0, g))), b++), f = f.substring(g), e = e.substring(g)),
                    g = this.diff_commonSuffix(f, e), 0 !== g && (a[b][1] = f.substring(f.length - g) + a[b][1], f = f.substring(0, f.length - g), e = e.substring(0, e.length - g))), b -= c + d, a.splice(b, c + d), e.length && (a.splice(b, 0, new diff_match_patch.Diff(DIFF_DELETE, e)), b++), f.length && (a.splice(b, 0, new diff_match_patch.Diff(DIFF_INSERT, f)), b++), b++) : 0 !== b && a[b - 1][0] == DIFF_EQUAL ? (a[b - 1][1] += a[b][1], a.splice(b, 1)) : b++, c = d = 0, f = e = ""
            }"" === a[a.length - 1][1] && a.pop(); c = !1; for (b = 1; b < a.length - 1;)a[b - 1][0] == DIFF_EQUAL && a[b + 1][0] == DIFF_EQUAL && (a[b][1].substring(a[b][1].length -
                a[b - 1][1].length) == a[b - 1][1] ? (a[b][1] = a[b - 1][1] + a[b][1].substring(0, a[b][1].length - a[b - 1][1].length), a[b + 1][1] = a[b - 1][1] + a[b + 1][1], a.splice(b - 1, 1), c = !0) : a[b][1].substring(0, a[b + 1][1].length) == a[b + 1][1] && (a[b - 1][1] += a[b + 1][1], a[b][1] = a[b][1].substring(a[b + 1][1].length) + a[b + 1][1], a.splice(b + 1, 1), c = !0)), b++; c && this.diff_cleanupMerge(a)
        };
        diff_match_patch.prototype.diff_xIndex = function (a, b) { var c = 0, d = 0, e = 0, f = 0, g; for (g = 0; g < a.length; g++) { a[g][0] !== DIFF_INSERT && (c += a[g][1].length); a[g][0] !== DIFF_DELETE && (d += a[g][1].length); if (c > b) break; e = c; f = d } return a.length != g && a[g][0] === DIFF_DELETE ? f : f + (b - e) };
        diff_match_patch.prototype.diff_prettyHtml = function (a) { for (var b = [], c = /&/g, d = /</g, e = />/g, f = /\n/g, g = 0; g < a.length; g++) { var h = a[g][0], l = a[g][1].replace(c, "&amp;").replace(d, "&lt;").replace(e, "&gt;").replace(f, "&para;<br>"); switch (h) { case DIFF_INSERT: b[g] = '<ins style="background:#e6ffe6;">' + l + "</ins>"; break; case DIFF_DELETE: b[g] = '<del style="background:#ffe6e6;">' + l + "</del>"; break; case DIFF_EQUAL: b[g] = "<span>" + l + "</span>" } } return b.join("") };
        diff_match_patch.prototype.diff_text1 = function (a) { for (var b = [], c = 0; c < a.length; c++)a[c][0] !== DIFF_INSERT && (b[c] = a[c][1]); return b.join("") }; diff_match_patch.prototype.diff_text2 = function (a) { for (var b = [], c = 0; c < a.length; c++)a[c][0] !== DIFF_DELETE && (b[c] = a[c][1]); return b.join("") };
        diff_match_patch.prototype.diff_levenshtein = function (a) { for (var b = 0, c = 0, d = 0, e = 0; e < a.length; e++) { var f = a[e][1]; switch (a[e][0]) { case DIFF_INSERT: c += f.length; break; case DIFF_DELETE: d += f.length; break; case DIFF_EQUAL: b += Math.max(c, d), d = c = 0 } } return b += Math.max(c, d) };
        diff_match_patch.prototype.diff_toDelta = function (a) { for (var b = [], c = 0; c < a.length; c++)switch (a[c][0]) { case DIFF_INSERT: b[c] = "+" + encodeURI(a[c][1]); break; case DIFF_DELETE: b[c] = "-" + a[c][1].length; break; case DIFF_EQUAL: b[c] = "=" + a[c][1].length }return b.join("\t").replace(/%20/g, " ") };
        diff_match_patch.prototype.diff_fromDelta = function (a, b) {
            for (var c = [], d = 0, e = 0, f = b.split(/\t/g), g = 0; g < f.length; g++) {
                var h = f[g].substring(1); switch (f[g].charAt(0)) {
                    case "+": try { c[d++] = new diff_match_patch.Diff(DIFF_INSERT, decodeURI(h)) } catch (k) { throw Error("Illegal escape in diff_fromDelta: " + h); } break; case "-": case "=": var l = parseInt(h, 10); if (isNaN(l) || 0 > l) throw Error("Invalid number in diff_fromDelta: " + h); h = a.substring(e, e += l); "=" == f[g].charAt(0) ? c[d++] = new diff_match_patch.Diff(DIFF_EQUAL, h) : c[d++] =
                        new diff_match_patch.Diff(DIFF_DELETE, h); break; default: if (f[g]) throw Error("Invalid diff operation in diff_fromDelta: " + f[g]);
                }
            } if (e != a.length) throw Error("Delta length (" + e + ") does not equal source text length (" + a.length + ")."); return c
        }; diff_match_patch.prototype.match_main = function (a, b, c) { if (null == a || null == b || null == c) throw Error("Null input. (match_main)"); c = Math.max(0, Math.min(c, a.length)); return a == b ? 0 : a.length ? a.substring(c, c + b.length) == b ? c : this.match_bitap_(a, b, c) : -1 };
        diff_match_patch.prototype.match_bitap_ = function (a, b, c) {
            function d(a, d) { var e = a / b.length, g = Math.abs(c - d); return f.Match_Distance ? e + g / f.Match_Distance : g ? 1 : e } if (b.length > this.Match_MaxBits) throw Error("Pattern too long for this browser."); var e = this.match_alphabet_(b), f = this, g = this.Match_Threshold, h = a.indexOf(b, c); -1 != h && (g = Math.min(d(0, h), g), h = a.lastIndexOf(b, c + b.length), -1 != h && (g = Math.min(d(0, h), g))); var l = 1 << b.length - 1; h = -1; for (var k, m, p = b.length + a.length, x, w = 0; w < b.length; w++) {
                k = 0; for (m = p; k < m;)d(w,
                    c + m) <= g ? k = m : p = m, m = Math.floor((p - k) / 2 + k); p = m; k = Math.max(1, c - m + 1); var q = Math.min(c + m, a.length) + b.length; m = Array(q + 2); for (m[q + 1] = (1 << w) - 1; q >= k; q--) { var t = e[a.charAt(q - 1)]; m[q] = 0 === w ? (m[q + 1] << 1 | 1) & t : (m[q + 1] << 1 | 1) & t | (x[q + 1] | x[q]) << 1 | 1 | x[q + 1]; if (m[q] & l && (t = d(w, q - 1), t <= g)) if (g = t, h = q - 1, h > c) k = Math.max(1, 2 * c - h); else break } if (d(w + 1, c) > g) break; x = m
            } return h
        };
        diff_match_patch.prototype.match_alphabet_ = function (a) { for (var b = {}, c = 0; c < a.length; c++)b[a.charAt(c)] = 0; for (c = 0; c < a.length; c++)b[a.charAt(c)] |= 1 << a.length - c - 1; return b };
        diff_match_patch.prototype.patch_addContext_ = function (a, b) {
            if (0 != b.length) {
                if (null === a.start2) throw Error("patch not initialized"); for (var c = b.substring(a.start2, a.start2 + a.length1), d = 0; b.indexOf(c) != b.lastIndexOf(c) && c.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin;)d += this.Patch_Margin, c = b.substring(a.start2 - d, a.start2 + a.length1 + d); d += this.Patch_Margin; (c = b.substring(a.start2 - d, a.start2)) && a.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, c)); (d = b.substring(a.start2 + a.length1,
                    a.start2 + a.length1 + d)) && a.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, d)); a.start1 -= c.length; a.start2 -= c.length; a.length1 += c.length + d.length; a.length2 += c.length + d.length
            }
        };
        diff_match_patch.prototype.patch_make = function (a, b, c) {
            if ("string" == typeof a && "string" == typeof b && "undefined" == typeof c) { var d = a; b = this.diff_main(d, b, !0); 2 < b.length && (this.diff_cleanupSemantic(b), this.diff_cleanupEfficiency(b)) } else if (a && "object" == typeof a && "undefined" == typeof b && "undefined" == typeof c) b = a, d = this.diff_text1(b); else if ("string" == typeof a && b && "object" == typeof b && "undefined" == typeof c) d = a; else if ("string" == typeof a && "string" == typeof b && c && "object" == typeof c) d = a, b = c; else throw Error("Unknown call format to patch_make.");
            if (0 === b.length) return []; c = []; a = new diff_match_patch.patch_obj; for (var e = 0, f = 0, g = 0, h = d, l = 0; l < b.length; l++) {
                var k = b[l][0], m = b[l][1]; e || k === DIFF_EQUAL || (a.start1 = f, a.start2 = g); switch (k) {
                    case DIFF_INSERT: a.diffs[e++] = b[l]; a.length2 += m.length; d = d.substring(0, g) + m + d.substring(g); break; case DIFF_DELETE: a.length1 += m.length; a.diffs[e++] = b[l]; d = d.substring(0, g) + d.substring(g + m.length); break; case DIFF_EQUAL: m.length <= 2 * this.Patch_Margin && e && b.length != l + 1 ? (a.diffs[e++] = b[l], a.length1 += m.length, a.length2 += m.length) :
                        m.length >= 2 * this.Patch_Margin && e && (this.patch_addContext_(a, h), c.push(a), a = new diff_match_patch.patch_obj, e = 0, h = d, f = g)
                }k !== DIFF_INSERT && (f += m.length); k !== DIFF_DELETE && (g += m.length)
            } e && (this.patch_addContext_(a, h), c.push(a)); return c
        };
        diff_match_patch.prototype.patch_deepCopy = function (a) { for (var b = [], c = 0; c < a.length; c++) { var d = a[c], e = new diff_match_patch.patch_obj; e.diffs = []; for (var f = 0; f < d.diffs.length; f++)e.diffs[f] = new diff_match_patch.Diff(d.diffs[f][0], d.diffs[f][1]); e.start1 = d.start1; e.start2 = d.start2; e.length1 = d.length1; e.length2 = d.length2; b[c] = e } return b };
        diff_match_patch.prototype.patch_apply = function (a, b) {
            if (0 == a.length) return [b, []]; a = this.patch_deepCopy(a); var c = this.patch_addPadding(a); b = c + b + c; this.patch_splitMax(a); for (var d = 0, e = [], f = 0; f < a.length; f++) {
                var g = a[f].start2 + d, h = this.diff_text1(a[f].diffs), l = -1; if (h.length > this.Match_MaxBits) { var k = this.match_main(b, h.substring(0, this.Match_MaxBits), g); -1 != k && (l = this.match_main(b, h.substring(h.length - this.Match_MaxBits), g + h.length - this.Match_MaxBits), -1 == l || k >= l) && (k = -1) } else k = this.match_main(b, h,
                    g); if (-1 == k) e[f] = !1, d -= a[f].length2 - a[f].length1; else if (e[f] = !0, d = k - g, g = -1 == l ? b.substring(k, k + h.length) : b.substring(k, l + this.Match_MaxBits), h == g) b = b.substring(0, k) + this.diff_text2(a[f].diffs) + b.substring(k + h.length); else if (g = this.diff_main(h, g, !1), h.length > this.Match_MaxBits && this.diff_levenshtein(g) / h.length > this.Patch_DeleteThreshold) e[f] = !1; else {
                        this.diff_cleanupSemanticLossless(g); h = 0; var m; for (l = 0; l < a[f].diffs.length; l++) {
                            var p = a[f].diffs[l]; p[0] !== DIFF_EQUAL && (m = this.diff_xIndex(g, h)); p[0] ===
                                DIFF_INSERT ? b = b.substring(0, k + m) + p[1] + b.substring(k + m) : p[0] === DIFF_DELETE && (b = b.substring(0, k + m) + b.substring(k + this.diff_xIndex(g, h + p[1].length))); p[0] !== DIFF_DELETE && (h += p[1].length)
                        }
                    }
            } b = b.substring(c.length, b.length - c.length); return [b, e]
        };
        diff_match_patch.prototype.patch_addPadding = function (a) {
            for (var b = this.Patch_Margin, c = "", d = 1; d <= b; d++)c += String.fromCharCode(d); for (d = 0; d < a.length; d++)a[d].start1 += b, a[d].start2 += b; d = a[0]; var e = d.diffs; if (0 == e.length || e[0][0] != DIFF_EQUAL) e.unshift(new diff_match_patch.Diff(DIFF_EQUAL, c)), d.start1 -= b, d.start2 -= b, d.length1 += b, d.length2 += b; else if (b > e[0][1].length) { var f = b - e[0][1].length; e[0][1] = c.substring(e[0][1].length) + e[0][1]; d.start1 -= f; d.start2 -= f; d.length1 += f; d.length2 += f } d = a[a.length - 1]; e = d.diffs;
            0 == e.length || e[e.length - 1][0] != DIFF_EQUAL ? (e.push(new diff_match_patch.Diff(DIFF_EQUAL, c)), d.length1 += b, d.length2 += b) : b > e[e.length - 1][1].length && (f = b - e[e.length - 1][1].length, e[e.length - 1][1] += c.substring(0, f), d.length1 += f, d.length2 += f); return c
        };
        diff_match_patch.prototype.patch_splitMax = function (a) {
            for (var b = this.Match_MaxBits, c = 0; c < a.length; c++)if (!(a[c].length1 <= b)) {
                var d = a[c]; a.splice(c--, 1); for (var e = d.start1, f = d.start2, g = ""; 0 !== d.diffs.length;) {
                    var h = new diff_match_patch.patch_obj, l = !0; h.start1 = e - g.length; h.start2 = f - g.length; "" !== g && (h.length1 = h.length2 = g.length, h.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, g))); for (; 0 !== d.diffs.length && h.length1 < b - this.Patch_Margin;) {
                        g = d.diffs[0][0]; var k = d.diffs[0][1]; g === DIFF_INSERT ? (h.length2 +=
                            k.length, f += k.length, h.diffs.push(d.diffs.shift()), l = !1) : g === DIFF_DELETE && 1 == h.diffs.length && h.diffs[0][0] == DIFF_EQUAL && k.length > 2 * b ? (h.length1 += k.length, e += k.length, l = !1, h.diffs.push(new diff_match_patch.Diff(g, k)), d.diffs.shift()) : (k = k.substring(0, b - h.length1 - this.Patch_Margin), h.length1 += k.length, e += k.length, g === DIFF_EQUAL ? (h.length2 += k.length, f += k.length) : l = !1, h.diffs.push(new diff_match_patch.Diff(g, k)), k == d.diffs[0][1] ? d.diffs.shift() : d.diffs[0][1] = d.diffs[0][1].substring(k.length))
                    } g = this.diff_text2(h.diffs);
                    g = g.substring(g.length - this.Patch_Margin); k = this.diff_text1(d.diffs).substring(0, this.Patch_Margin); "" !== k && (h.length1 += k.length, h.length2 += k.length, 0 !== h.diffs.length && h.diffs[h.diffs.length - 1][0] === DIFF_EQUAL ? h.diffs[h.diffs.length - 1][1] += k : h.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, k))); l || a.splice(++c, 0, h)
                }
            }
        }; diff_match_patch.prototype.patch_toText = function (a) { for (var b = [], c = 0; c < a.length; c++)b[c] = a[c]; return b.join("") };
        diff_match_patch.prototype.patch_fromText = function (a) {
            var b = []; if (!a) return b; a = a.split("\n"); for (var c = 0, d = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/; c < a.length;) {
                var e = a[c].match(d); if (!e) throw Error("Invalid patch string: " + a[c]); var f = new diff_match_patch.patch_obj; b.push(f); f.start1 = parseInt(e[1], 10); "" === e[2] ? (f.start1--, f.length1 = 1) : "0" == e[2] ? f.length1 = 0 : (f.start1--, f.length1 = parseInt(e[2], 10)); f.start2 = parseInt(e[3], 10); "" === e[4] ? (f.start2--, f.length2 = 1) : "0" == e[4] ? f.length2 = 0 : (f.start2--, f.length2 =
                    parseInt(e[4], 10)); for (c++; c < a.length;) { e = a[c].charAt(0); try { var g = decodeURI(a[c].substring(1)) } catch (h) { throw Error("Illegal escape in patch_fromText: " + g); } if ("-" == e) f.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, g)); else if ("+" == e) f.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, g)); else if (" " == e) f.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, g)); else if ("@" == e) break; else if ("" !== e) throw Error('Invalid patch mode "' + e + '" in: ' + g); c++ }
            } return b
        };
        diff_match_patch.patch_obj = function () { this.diffs = []; this.start2 = this.start1 = null; this.length2 = this.length1 = 0 };
        diff_match_patch.patch_obj.prototype.toString = function () { for (var a = ["@@ -" + (0 === this.length1 ? this.start1 + ",0" : 1 == this.length1 ? this.start1 + 1 : this.start1 + 1 + "," + this.length1) + " +" + (0 === this.length2 ? this.start2 + ",0" : 1 == this.length2 ? this.start2 + 1 : this.start2 + 1 + "," + this.length2) + " @@\n"], b, c = 0; c < this.diffs.length; c++) { switch (this.diffs[c][0]) { case DIFF_INSERT: b = "+"; break; case DIFF_DELETE: b = "-"; break; case DIFF_EQUAL: b = " " }a[c + 1] = b + encodeURI(this.diffs[c][1]) + "\n" } return a.join("").replace(/%20/g, " ") };
        this.diff_match_patch = diff_match_patch; this.DIFF_DELETE = DIFF_DELETE; this.DIFF_INSERT = DIFF_INSERT; this.DIFF_EQUAL = DIFF_EQUAL;

        // APP LOGIC
        const dmp = new diff_match_patch();

        const oldInput = document.getElementById('old-input');
        const newInput = document.getElementById('new-input');
        const oldDiffView = document.getElementById('old-diff-view');
        const newDiffView = document.getElementById('new-diff-view');
        const statusBar = document.getElementById('status-bar');
        const undoBtn = document.getElementById('undo-btn');
        const cycleBtn = document.getElementById('cycle-btn');

        let history = [];
        let currentOld = "";
        let currentNew = "";

        function escapeHtml(text) {
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function updateDiff() {
            const text1 = oldInput.value;
            const text2 = newInput.value;

            currentOld = text1;
            currentNew = text2;

            document.getElementById('old-len').textContent = `${text1.length} chars`;
            document.getElementById('new-len').textContent = `${text2.length} chars`;

            const diffs = dmp.diff_main(text1, text2);
            dmp.diff_cleanupSemantic(diffs);

            calculateLineMaps(diffs);

            // Render Old View (Deletions + Context)
            // We want to show what was there, highlighting deletions.
            // Insertions in the new text are not shown in the old view (or maybe just as context?)
            // Actually, standard diff view:
            // Left: Shows original text, highlights deletions in red.
            // Right: Shows new text, highlights insertions in green.

            let oldHtml = "";
            let newHtml = "";

            diffs.forEach(part => {
                const type = part[0];
                const text = part[1];
                const escapedText = escapeHtml(text);

                if (type === DIFF_DELETE) {
                    oldHtml += `<del>${escapedText}</del>`;
                } else if (type === DIFF_INSERT) {
                    newHtml += `<ins>${escapedText}</ins>`;
                } else {
                    oldHtml += `<span>${escapedText}</span>`;
                    newHtml += `<span>${escapedText}</span>`;
                }
            });

            // We need to handle newlines properly for the overlay to match the textarea
            // The textarea has white-space: pre. The div has white-space: pre-wrap.
            // Actually, both should be pre-wrap or pre. Let's stick to pre-wrap for now to handle long lines?
            // But source code usually scrolls.
            // Let's force both to white-space: pre; in CSS.

            oldDiffView.innerHTML = oldHtml;
            newDiffView.innerHTML = newHtml;
        }

        // Scroll Sync Logic
        let isSyncingLeft = false;
        let isSyncingRight = false;
        const LINE_HEIGHT = 21;

        // Maps line numbers: index is line number in source, value is line number in target
        let oldToNewMap = [];
        let newToOldMap = [];

        function calculateLineMaps(diffs) {
            oldToNewMap = [];
            newToOldMap = [];

            let oldLine = 0;
            let newLine = 0;

            diffs.forEach(part => {
                const type = part[0];
                const text = part[1];
                // Count newlines in this diff part
                const lines = (text.match(/\n/g) || []).length;

                if (type === DIFF_EQUAL) {
                    for (let i = 0; i < lines; i++) {
                        oldToNewMap[oldLine + i] = newLine + i;
                        newToOldMap[newLine + i] = oldLine + i;
                    }
                    oldLine += lines;
                    newLine += lines;
                } else if (type === DIFF_DELETE) {
                    for (let i = 0; i < lines; i++) {
                        oldToNewMap[oldLine + i] = newLine; // Map to current new line
                    }
                    oldLine += lines;
                } else if (type === DIFF_INSERT) {
                    for (let i = 0; i < lines; i++) {
                        newToOldMap[newLine + i] = oldLine; // Map to current old line
                    }
                    newLine += lines;
                }
            });

            // Handle remaining partial lines or single line files
            // If the file doesn't end with newline, we might be off by one in mapping if we strictly count \n.
            // But for scrolling purposes, it's usually fine.
        }

        oldInput.addEventListener('scroll', () => {
            // Always sync the overlay
            oldDiffView.scrollTop = oldInput.scrollTop;
            oldDiffView.scrollLeft = oldInput.scrollLeft;

            if (!isSyncingLeft) {
                isSyncingRight = true;

                const oldScrollTop = oldInput.scrollTop;
                const oldLineIdx = Math.round(oldScrollTop / LINE_HEIGHT);

                // Calculate target new line
                let newLineIdx = 0;
                if (oldLineIdx < oldToNewMap.length) {
                    newLineIdx = oldToNewMap[oldLineIdx];
                } else {
                    newLineIdx = oldToNewMap.length > 0 ? oldToNewMap[oldToNewMap.length - 1] : 0;
                }
                if (newLineIdx === undefined) newLineIdx = 0;

                // STABILITY CHECK & OFFSET CLAMPING
                const currentNewScrollTop = newInput.scrollTop;
                const currentNewLineIdx = Math.round(currentNewScrollTop / LINE_HEIGHT);

                let checkOldIdx = 0;
                if (currentNewLineIdx < newToOldMap.length) {
                    checkOldIdx = newToOldMap[currentNewLineIdx];
                } else {
                    checkOldIdx = newToOldMap.length > 0 ? newToOldMap[newToOldMap.length - 1] : 0;
                }

                // If the New panel is already at a line that maps to our current Old line, do nothing.
                if (checkOldIdx !== oldLineIdx) {
                    let newScrollTop = newLineIdx * LINE_HEIGHT;

                    // Only sync offset if it's a 1-to-1 mapping start
                    // i.e. if the target new line maps back exactly to our old line
                    // AND the next old line maps to the next new line (continuity)
                    // Or simpler: if newToOldMap[newLineIdx] == oldLineIdx. (Which is true by definition of newLineIdx)
                    // But we need to know if we are "drifting".

                    // If we are in a block where Old X -> New Y, but Old X+1 -> New Y (Deletion in New / Many Old to One New)
                    // Then we should NOT add offset?
                    // Actually, if Old X -> New Y, Old X+1 -> New Y.
                    // Scrolling Old from X to X+1 should NOT move New from Y.
                    // So we should clamp New to Y.

                    // Check if next line maps to same target
                    let nextNewLineIdx = newLineIdx;
                    if (oldLineIdx + 1 < oldToNewMap.length) {
                        nextNewLineIdx = oldToNewMap[oldLineIdx + 1];
                    }

                    if (nextNewLineIdx !== newLineIdx) {
                        // 1-to-1 or at least moving target. Sync offset.
                        const offset = oldScrollTop % LINE_HEIGHT;
                        newScrollTop += offset;
                    } else {
                        // Many-to-One (Deletion). Clamp to top.
                        // newScrollTop remains at line start.
                    }

                    newInput.scrollTop = newScrollTop;

                    // Sync overlay
                    newDiffView.scrollTop = newInput.scrollTop;
                    newDiffView.scrollLeft = newInput.scrollLeft;
                }

                setTimeout(() => isSyncingRight = false, 10);
            }
        });

        newInput.addEventListener('scroll', () => {
            // Always sync the overlay
            newDiffView.scrollTop = newInput.scrollTop;
            newDiffView.scrollLeft = newInput.scrollLeft;

            if (!isSyncingRight) {
                isSyncingLeft = true;

                const newScrollTop = newInput.scrollTop;
                const newLineIdx = Math.round(newScrollTop / LINE_HEIGHT);

                let oldLineIdx = 0;
                if (newLineIdx < newToOldMap.length) {
                    oldLineIdx = newToOldMap[newLineIdx];
                } else {
                    oldLineIdx = newToOldMap.length > 0 ? newToOldMap[newToOldMap.length - 1] : 0;
                }
                if (oldLineIdx === undefined) oldLineIdx = 0;

                // STABILITY CHECK
                const currentOldScrollTop = oldInput.scrollTop;
                const currentOldLineIdx = Math.round(currentOldScrollTop / LINE_HEIGHT);

                let checkNewIdx = 0;
                if (currentOldLineIdx < oldToNewMap.length) {
                    checkNewIdx = oldToNewMap[currentOldLineIdx];
                } else {
                    checkNewIdx = oldToNewMap.length > 0 ? oldToNewMap[oldToNewMap.length - 1] : 0;
                }

                if (checkNewIdx !== newLineIdx) {
                    let oldScrollTop = oldLineIdx * LINE_HEIGHT;

                    // Check if next line maps to same target (Insertion in New / Many New to One Old)
                    let nextOldLineIdx = oldLineIdx;
                    if (newLineIdx + 1 < newToOldMap.length) {
                        nextOldLineIdx = newToOldMap[newLineIdx + 1];
                    }

                    if (nextOldLineIdx !== oldLineIdx) {
                        // 1-to-1. Sync offset.
                        const offset = newScrollTop % LINE_HEIGHT;
                        oldScrollTop += offset;
                    } else {
                        // Many-to-One (Insertion). Clamp to top.
                    }

                    oldInput.scrollTop = oldScrollTop;

                    // Sync overlay
                    oldDiffView.scrollTop = oldInput.scrollTop;
                    oldDiffView.scrollLeft = oldInput.scrollLeft;
                }

                setTimeout(() => isSyncingLeft = false, 10);
            }
        });

        // Input listeners
        oldInput.addEventListener('input', updateDiff);
        newInput.addEventListener('input', updateDiff);

        // Paste listener for cycling
        newInput.addEventListener('paste', (e) => {
            // If the new pane is not empty, we might want to cycle.
            // Logic: If New pane has content, and we paste, we assume the user wants to compare against the current New.
            // So current New becomes Old.

            if (newInput.value.trim().length > 0) {
                // Save history
                history.push({
                    old: oldInput.value,
                    new: newInput.value
                });

                // Cycle: Old = New
                oldInput.value = newInput.value;

                // The pasted content will naturally go into New input by default behavior.
                // However, we want to ensure the cycle happens BEFORE the paste replaces the content?
                // Actually, the paste event happens before the content is inserted.
                // So we move current New to Old.
                // Then we let the paste happen into New (which is now effectively empty or about to be replaced).

                // Wait, if we just set oldInput.value, the paste will still insert into newInput at cursor.
                // If we want to REPLACE newInput with pasted content, we should prevent default and insert manually?
                // Or just let it happen.

                // User requirement: "I paste version 63. Immediately, version 62 is moved from panel 'new' to panel 'old'"

                // If we just move the text, the paste will insert into the "New" pane (which still has the text unless we clear it).
                // If we clear it, the paste will insert into an empty pane.

                // Let's try:
                // 1. Move New val to Old val.
                // 2. Clear New val.
                // 3. Let paste happen (it will paste into the now empty New val).

                // But wait, if the user is just pasting a snippet into the middle of the file?
                // The requirement says "pasting a new version". Implies full replacement usually.
                // But "The 'new' panel should be editable".

                // Heuristic: If the paste is large (e.g. > 50 chars) or the user explicitly wants to cycle?
                // The user said "The crucial feature is that pasting a new version should make the previous versions circle".
                // This implies a full replacement workflow.

                // Let's implement the cycle on paste if the New pane is not empty.
                // We will clear the New pane so the paste replaces everything.

                // To be safe, let's only do this if the New pane has significant content?
                // Or maybe just do it.

                // Let's add a small check: if the New pane is empty, just paste.
                // If New pane has content, cycle then paste.

                // We need to prevent default paste if we want to guarantee full replacement?
                // Or just select all and paste?

                // Let's do:
                // 1. Copy New -> Old.
                // 2. Select All in New.
                // 3. Let paste happen (replacing selection).

                // Actually, programmatically changing focus/selection in paste event might be tricky.

                // Better:
                // 1. Copy New -> Old.
                // 2. Clear New.
                // 3. Let paste happen.

                // But we need to update the diff immediately.

                // Let's try this:
                e.preventDefault(); // Stop default paste
                const text = (e.clipboardData || window.clipboardData).getData('text');

                // Cycle
                oldInput.value = newInput.value;
                newInput.value = text;

                updateDiff();
                statusBar.textContent = "Cycled versions and pasted new content.";
            } else {
                // Normal paste into empty New pane
                // Just let it happen? Or handle it to trigger updateDiff
                setTimeout(updateDiff, 0);
            }
        });

        undoBtn.addEventListener('click', () => {
            if (history.length > 0) {
                const state = history.pop();
                oldInput.value = state.old;
                newInput.value = state.new;
                updateDiff();
                statusBar.textContent = "Undid last cycle.";
            } else {
                statusBar.textContent = "Nothing to undo.";
            }
        });

        cycleBtn.addEventListener('click', () => {
            history.push({
                old: oldInput.value,
                new: newInput.value
            });
            oldInput.value = newInput.value;
            newInput.value = "";
            updateDiff();
            statusBar.textContent = "Cycled versions. New pane is empty.";
            newInput.focus();
        });

        // Initial render
        updateDiff();

    </script>
</body>

</html>
